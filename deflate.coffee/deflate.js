// Generated by CoffeeScript 1.3.1
(function() {

  (function() {
    var RawDeflate, fixed_bd, zip_DUMPBITS, zip_DYN_TREES, zip_GETBITS, zip_GET_BYTE, zip_HuftBuild, zip_HuftList, zip_HuftNode, zip_INBUFSIZ, zip_INBUF_EXTRA, zip_MASK_BITS, zip_NEEDBITS, zip_STATIC_TREES, zip_STORED_BLOCK, zip_WSIZE, zip_bd, zip_bit_buf, zip_bit_len, zip_bl, zip_border, zip_copy_dist, zip_copy_leng, zip_cpdext, zip_cpdist, zip_cplens, zip_cplext, zip_dbits, zip_eof, zip_fixed_bl, zip_fixed_td, zip_fixed_tl, zip_inflate, zip_inflate_codes, zip_inflate_data, zip_inflate_dynamic, zip_inflate_fixed, zip_inflate_internal, zip_inflate_pos, zip_inflate_start, zip_inflate_stored, zip_lbits, zip_method, zip_slide, zip_td, zip_tl, zip_wp;
    zip_WSIZE = 32768;
    zip_STORED_BLOCK = 0;
    zip_STATIC_TREES = 1;
    zip_DYN_TREES = 2;
    zip_lbits = 9;
    zip_dbits = 6;
    zip_INBUFSIZ = 32768;
    zip_INBUF_EXTRA = 64;
    zip_slide = void 0;
    zip_wp = void 0;
    zip_fixed_tl = null;
    zip_fixed_td = void 0;
    zip_fixed_bl = void 0;
    fixed_bd = void 0;
    zip_bit_buf = void 0;
    zip_bit_len = void 0;
    zip_method = void 0;
    zip_eof = void 0;
    zip_copy_leng = void 0;
    zip_copy_dist = void 0;
    zip_tl = void 0;
    zip_td = void 0;
    zip_bl = void 0;
    zip_bd = void 0;
    zip_inflate_data = void 0;
    zip_inflate_pos = void 0;
    zip_MASK_BITS = new Array(0x0000, 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff, 0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff);
    zip_cplens = new Array(3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0);
    zip_cplext = new Array(0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99);
    zip_cpdist = new Array(1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577);
    zip_cpdext = new Array(0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13);
    zip_border = new Array(16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15);
    zip_HuftList = function() {
      this.next = null;
      return this.list = null;
    };
    zip_HuftNode = function() {
      this.e = 0;
      this.b = 0;
      this.n = 0;
      return this.t = null;
    };
    zip_HuftBuild = function(b, n, s, d, e, mm) {
      var a, c, el, f, g, h, i, j, k, lx, o, p, pidx, q, r, tail, u, v, w, x, xp, y, z;
      this.BMAX = 16;
      this.N_MAX = 288;
      this.status = 0;
      this.root = null;
      this.m = 0;
      a = void 0;
      c = new Array(this.BMAX + 1);
      el = void 0;
      f = void 0;
      g = void 0;
      h = void 0;
      i = void 0;
      j = void 0;
      k = void 0;
      lx = new Array(this.BMAX + 1);
      p = void 0;
      pidx = void 0;
      q = void 0;
      r = new zip_HuftNode();
      u = new Array(this.BMAX);
      v = new Array(this.N_MAX);
      w = void 0;
      x = new Array(this.BMAX + 1);
      xp = void 0;
      y = void 0;
      z = void 0;
      o = void 0;
      tail = void 0;
      tail = this.root = null;
      i = 0;
      while (i < c.length) {
        c[i] = 0;
        i++;
      }
      i = 0;
      while (i < lx.length) {
        lx[i] = 0;
        i++;
      }
      i = 0;
      while (i < u.length) {
        u[i] = null;
        i++;
      }
      i = 0;
      while (i < v.length) {
        v[i] = 0;
        i++;
      }
      i = 0;
      while (i < x.length) {
        x[i] = 0;
        i++;
      }
      el = (n > 256 ? b[256] : this.BMAX);
      p = b;
      pidx = 0;
      i = n;
      while (true) {
        c[p[pidx]]++;
        pidx++;
        if (!(--i > 0)) {
          break;
        }
      }
      if (c[0] === n) {
        this.root = null;
        this.m = 0;
        this.status = 0;
        return;
      }
      j = 1;
      while (j <= this.BMAX) {
        if (c[j] !== 0) {
          break;
        }
        j++;
      }
      k = j;
      if (mm < j) {
        mm = j;
      }
      i = this.BMAX;
      while (i !== 0) {
        if (c[i] !== 0) {
          break;
        }
        i--;
      }
      g = i;
      if (mm > i) {
        mm = i;
      }
      y = 1 << j;
      while (j < i) {
        if ((y -= c[j]) < 0) {
          this.status = 2;
          this.m = mm;
          return;
        }
        j++;
        y <<= 1;
      }
      if ((y -= c[i]) < 0) {
        this.status = 2;
        this.m = mm;
        return;
      }
      c[i] += y;
      x[1] = j = 0;
      p = c;
      pidx = 1;
      xp = 2;
      while (--i > 0) {
        x[xp++] = (j += p[pidx++]);
      }
      p = b;
      pidx = 0;
      i = 0;
      while (true) {
        if ((j = p[pidx++]) !== 0) {
          v[x[j]++] = i;
        }
        if (!(++i < n)) {
          break;
        }
      }
      n = x[g];
      x[0] = i = 0;
      p = v;
      pidx = 0;
      h = -1;
      w = lx[0] = 0;
      q = null;
      z = 0;
      while (k <= g) {
        a = c[k];
        while (a-- > 0) {
          while (k > w + lx[1 + h]) {
            w += lx[1 + h];
            h++;
            z = ((z = g - w) > mm ? mm : z);
            if ((f = 1 << (j = k - w)) > a + 1) {
              f -= a + 1;
              xp = k;
              while (++j < z) {
                if ((f <<= 1) <= c[++xp]) {
                  break;
                }
                f -= c[xp];
              }
            }
            if (w + j > el && w < el) {
              j = el - w;
            }
            z = 1 << j;
            lx[1 + h] = j;
            q = new Array(z);
            o = 0;
            while (o < z) {
              q[o] = new zip_HuftNode();
              o++;
            }
            if (tail == null) {
              tail = this.root = new zip_HuftList();
            } else {
              tail = tail.next = new zip_HuftList();
            }
            tail.next = null;
            tail.list = q;
            u[h] = q;
            if (h > 0) {
              x[h] = i;
              r.b = lx[h];
              r.e = 16 + j;
              r.t = q;
              j = (i & ((1 << w) - 1)) >> (w - lx[h]);
              u[h - 1][j].e = r.e;
              u[h - 1][j].b = r.b;
              u[h - 1][j].n = r.n;
              u[h - 1][j].t = r.t;
            }
          }
          r.b = k - w;
          if (pidx >= n) {
            r.e = 99;
          } else if (p[pidx] < s) {
            r.e = (p[pidx] < 256 ? 16 : 15);
            r.n = p[pidx++];
          } else {
            r.e = e[p[pidx] - s];
            r.n = d[p[pidx++] - s];
          }
          f = 1 << (k - w);
          j = i >> w;
          while (j < z) {
            q[j].e = r.e;
            q[j].b = r.b;
            q[j].n = r.n;
            q[j].t = r.t;
            j += f;
          }
          j = 1 << (k - 1);
          while ((i & j) !== 0) {
            i ^= j;
            j >>= 1;
          }
          i ^= j;
          while ((i & ((1 << w) - 1)) !== x[h]) {
            w -= lx[h];
            h--;
          }
        }
        k++;
      }
      this.m = lx[1];
      return this.status = (y !== 0 && g !== 1 ? 1 : 0);
    };
    zip_GET_BYTE = function() {
      if (zip_inflate_data.length === zip_inflate_pos) {
        return -1;
      }
      return zip_inflate_data.charCodeAt(zip_inflate_pos++) & 0xff;
    };
    zip_NEEDBITS = function(n) {
      var _results;
      _results = [];
      while (zip_bit_len < n) {
        zip_bit_buf |= zip_GET_BYTE() << zip_bit_len;
        _results.push(zip_bit_len += 8);
      }
      return _results;
    };
    zip_GETBITS = function(n) {
      return zip_bit_buf & zip_MASK_BITS[n];
    };
    zip_DUMPBITS = function(n) {
      zip_bit_buf >>= n;
      return zip_bit_len -= n;
    };
    zip_inflate_codes = function(buff, off_, size) {
      var e, n, t;
      e = void 0;
      t = void 0;
      n = void 0;
      if (size === 0) {
        return 0;
      }
      n = 0;
      while (true) {
        zip_NEEDBITS(zip_bl);
        t = zip_tl.list[zip_GETBITS(zip_bl)];
        e = t.e;
        while (e > 16) {
          if (e === 99) {
            return -1;
          }
          zip_DUMPBITS(t.b);
          e -= 16;
          zip_NEEDBITS(e);
          t = t.t[zip_GETBITS(e)];
          e = t.e;
        }
        zip_DUMPBITS(t.b);
        if (e === 16) {
          zip_wp &= zip_WSIZE - 1;
          buff[off_ + n++] = zip_slide[zip_wp++] = t.n;
          if (n === size) {
            return size;
          }
          continue;
        }
        if (e === 15) {
          break;
        }
        zip_NEEDBITS(e);
        zip_copy_leng = t.n + zip_GETBITS(e);
        zip_DUMPBITS(e);
        zip_NEEDBITS(zip_bd);
        t = zip_td.list[zip_GETBITS(zip_bd)];
        e = t.e;
        while (e > 16) {
          if (e === 99) {
            return -1;
          }
          zip_DUMPBITS(t.b);
          e -= 16;
          zip_NEEDBITS(e);
          t = t.t[zip_GETBITS(e)];
          e = t.e;
        }
        zip_DUMPBITS(t.b);
        zip_NEEDBITS(e);
        zip_copy_dist = zip_wp - t.n - zip_GETBITS(e);
        zip_DUMPBITS(e);
        while (zip_copy_leng > 0 && n < size) {
          zip_copy_leng--;
          zip_copy_dist &= zip_WSIZE - 1;
          zip_wp &= zip_WSIZE - 1;
          buff[off_ + n++] = zip_slide[zip_wp++] = zip_slide[zip_copy_dist++];
        }
        if (n === size) {
          return size;
        }
      }
      zip_method = -1;
      return n;
    };
    zip_inflate_stored = function(buff, off_, size) {
      var n;
      n = void 0;
      n = zip_bit_len & 7;
      zip_DUMPBITS(n);
      zip_NEEDBITS(16);
      n = zip_GETBITS(16);
      zip_DUMPBITS(16);
      zip_NEEDBITS(16);
      if (n !== ((~zip_bit_buf) & 0xffff)) {
        return -1;
      }
      zip_DUMPBITS(16);
      zip_copy_leng = n;
      n = 0;
      while (zip_copy_leng > 0 && n < size) {
        zip_copy_leng--;
        zip_wp &= zip_WSIZE - 1;
        zip_NEEDBITS(8);
        buff[off_ + n++] = zip_slide[zip_wp++] = zip_GETBITS(8);
        zip_DUMPBITS(8);
      }
      if (zip_copy_leng === 0) {
        zip_method = -1;
      }
      return n;
    };
    zip_inflate_fixed = function(buff, off_, size) {
      var h, i, l, zip_fixed_bd;
      if (zip_fixed_tl == null) {
        i = void 0;
        l = new Array(288);
        h = void 0;
        i = 0;
        while (i < 144) {
          l[i] = 8;
          i++;
        }
        while (i < 256) {
          l[i] = 9;
          i++;
        }
        while (i < 280) {
          l[i] = 7;
          i++;
        }
        while (i < 288) {
          l[i] = 8;
          i++;
        }
        zip_fixed_bl = 7;
        h = new zip_HuftBuild(l, 288, 257, zip_cplens, zip_cplext, zip_fixed_bl);
        if (h.status !== 0) {
          alert("HufBuild error: " + h.status);
          return -1;
        }
        zip_fixed_tl = h.root;
        zip_fixed_bl = h.m;
        i = 0;
        while (i < 30) {
          l[i] = 5;
          i++;
        }
        zip_fixed_bd = 5;
        h = new zip_HuftBuild(l, 30, 0, zip_cpdist, zip_cpdext, zip_fixed_bd);
        if (h.status > 1) {
          zip_fixed_tl = null;
          alert("HufBuild error: " + h.status);
          return -1;
        }
        zip_fixed_td = h.root;
        zip_fixed_bd = h.m;
      }
      zip_tl = zip_fixed_tl;
      zip_td = zip_fixed_td;
      zip_bl = zip_fixed_bl;
      zip_bd = zip_fixed_bd;
      return zip_inflate_codes(buff, off_, size);
    };
    zip_inflate_dynamic = function(buff, off_, size) {
      var h, i, j, l, ll, n, nb, nd, nl, t;
      i = void 0;
      j = void 0;
      l = void 0;
      n = void 0;
      t = void 0;
      nb = void 0;
      nl = void 0;
      nd = void 0;
      ll = new Array(286 + 30);
      h = void 0;
      i = 0;
      while (i < ll.length) {
        ll[i] = 0;
        i++;
      }
      zip_NEEDBITS(5);
      nl = 257 + zip_GETBITS(5);
      zip_DUMPBITS(5);
      zip_NEEDBITS(5);
      nd = 1 + zip_GETBITS(5);
      zip_DUMPBITS(5);
      zip_NEEDBITS(4);
      nb = 4 + zip_GETBITS(4);
      zip_DUMPBITS(4);
      if (nl > 286 || nd > 30) {
        return -1;
      }
      j = 0;
      while (j < nb) {
        zip_NEEDBITS(3);
        ll[zip_border[j]] = zip_GETBITS(3);
        zip_DUMPBITS(3);
        j++;
      }
      while (j < 19) {
        ll[zip_border[j]] = 0;
        j++;
      }
      zip_bl = 7;
      h = new zip_HuftBuild(ll, 19, 19, null, null, zip_bl);
      if (h.status !== 0) {
        return -1;
      }
      zip_tl = h.root;
      zip_bl = h.m;
      n = nl + nd;
      i = l = 0;
      while (i < n) {
        zip_NEEDBITS(zip_bl);
        t = zip_tl.list[zip_GETBITS(zip_bl)];
        j = t.b;
        zip_DUMPBITS(j);
        j = t.n;
        if (j < 16) {
          ll[i++] = l = j;
        } else if (j === 16) {
          zip_NEEDBITS(2);
          j = 3 + zip_GETBITS(2);
          zip_DUMPBITS(2);
          if (i + j > n) {
            return -1;
          }
          while (j-- > 0) {
            ll[i++] = l;
          }
        } else if (j === 17) {
          zip_NEEDBITS(3);
          j = 3 + zip_GETBITS(3);
          zip_DUMPBITS(3);
          if (i + j > n) {
            return -1;
          }
          while (j-- > 0) {
            ll[i++] = 0;
          }
          l = 0;
        } else {
          zip_NEEDBITS(7);
          j = 11 + zip_GETBITS(7);
          zip_DUMPBITS(7);
          if (i + j > n) {
            return -1;
          }
          while (j-- > 0) {
            ll[i++] = 0;
          }
          l = 0;
        }
      }
      zip_bl = zip_lbits;
      h = new zip_HuftBuild(ll, nl, 257, zip_cplens, zip_cplext, zip_bl);
      if (zip_bl === 0) {
        h.status = 1;
      }
      if (h.status !== 0) {
        return -1;
      }
      zip_tl = h.root;
      zip_bl = h.m;
      i = 0;
      while (i < nd) {
        ll[i] = ll[i + nl];
        i++;
      }
      zip_bd = zip_dbits;
      h = new zip_HuftBuild(ll, nd, 0, zip_cpdist, zip_cpdext, zip_bd);
      zip_td = h.root;
      zip_bd = h.m;
      if (zip_bd === 0 && nl > 257) {
        return -1;
      }
      if (h.status !== 0) {
        return -1;
      }
      return zip_inflate_codes(buff, off_, size);
    };
    zip_inflate_start = function() {
      var i;
      i = void 0;
      if (zip_slide == null) {
        zip_slide = new Array(2 * zip_WSIZE);
      }
      zip_wp = 0;
      zip_bit_buf = 0;
      zip_bit_len = 0;
      zip_method = -1;
      zip_eof = false;
      zip_copy_leng = zip_copy_dist = 0;
      return zip_tl = null;
    };
    zip_inflate_internal = function(buff, off_, size) {
      var i, n;
      n = void 0;
      i = void 0;
      n = 0;
      while (n < size) {
        if (zip_eof && zip_method === -1) {
          return n;
        }
        if (zip_copy_leng > 0) {
          if (zip_method !== zip_STORED_BLOCK) {
            while (zip_copy_leng > 0 && n < size) {
              zip_copy_leng--;
              zip_copy_dist &= zip_WSIZE - 1;
              zip_wp &= zip_WSIZE - 1;
              buff[off_ + n++] = zip_slide[zip_wp++] = zip_slide[zip_copy_dist++];
            }
          } else {
            while (zip_copy_leng > 0 && n < size) {
              zip_copy_leng--;
              zip_wp &= zip_WSIZE - 1;
              zip_NEEDBITS(8);
              buff[off_ + n++] = zip_slide[zip_wp++] = zip_GETBITS(8);
              zip_DUMPBITS(8);
            }
            if (zip_copy_leng === 0) {
              zip_method = -1;
            }
          }
          if (n === size) {
            return n;
          }
        }
        if (zip_method === -1) {
          if (zip_eof) {
            break;
          }
          zip_NEEDBITS(1);
          if (zip_GETBITS(1) !== 0) {
            zip_eof = true;
          }
          zip_DUMPBITS(1);
          zip_NEEDBITS(2);
          zip_method = zip_GETBITS(2);
          zip_DUMPBITS(2);
          zip_tl = null;
          zip_copy_leng = 0;
        }
        switch (zip_method) {
          case 0:
            i = zip_inflate_stored(buff, off_ + n, size - n);
            break;
          case 1:
            if (zip_tl != null) {
              i = zip_inflate_codes(buff, off_ + n, size - n);
            } else {
              i = zip_inflate_fixed(buff, off_ + n, size - n);
            }
            break;
          case 2:
            if (zip_tl != null) {
              i = zip_inflate_codes(buff, off_ + n, size - n);
            } else {
              i = zip_inflate_dynamic(buff, off_ + n, size - n);
            }
            break;
          default:
            i = -1;
        }
        if (i === -1) {
          if (zip_eof) {
            return 0;
          }
          return -1;
        }
        n += i;
      }
      return n;
    };
    zip_inflate = function(str) {
      var aout, buff, cbuf, i, j;
      i = void 0;
      j = void 0;
      zip_inflate_start();
      zip_inflate_data = str;
      zip_inflate_pos = 0;
      buff = new Array(1024);
      aout = [];
      while ((i = zip_inflate_internal(buff, 0, buff.length)) > 0) {
        cbuf = new Array(i);
        j = 0;
        while (j < i) {
          cbuf[j] = String.fromCharCode(buff[j]);
          j++;
        }
        aout[aout.length] = cbuf.join("");
      }
      zip_inflate_data = null;
      return aout.join("");
    };
    if (!window.RawDeflate) {
      RawDeflate = {};
    }
    return RawDeflate.inflate = zip_inflate;
  })();

}).call(this);
